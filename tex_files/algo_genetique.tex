\section{Optimisation des paramètres par algorithme génétique}
\label{sec:gen}


Afin de sélectionner la meilleure position verrouillable par 
l'algorithme principal, il faut lui attribuer un score qui est une somme
pondérée de différents indicateurs numériques.
Ces coefficients de pondération, qui sont tous des entiers naturels, ont été choisis \ofg{au 
doigt mouillé} dans un premier temps en fonction de l'intuition que l'on avait 
de leur effet potentiel, mais une fois l'algorithme lâché sur un problème, il 
n'est pas certain que le choix soit optimal. On a donc décidé d'utiliser un 
algorithme génétique pour essayer de trouver rapidement un jeu de pondérations 
qui puissent faire mieux que le jeu par défaut.

\subsection{Idée de l'algorithme génétique}

Le principe de l'algorithme génétique est de faire \ofg{s'affronter} 
différents jeux de paramètres pour pouvoir les classer en fonction d'un 
certain critère (ici, ce sera le score total sur l'ensemble des problèmes 
soumis). Une fois les différents candidats rangés par ordre d'efficacités, on 
sélectionne les meilleurs et on les \ofg{reproduit} entre eux en mélangeant 
leurs caractéristiques principales pour former un certains nombre de 
programmes \ofg{fils}. Les parents et les enfants s'affrontent alors à nouveau 
sur le jeu de problèmes et on resélectionne les meilleurs du cheptel pour la 
reproduction afin de produire une nouvelle génération. Au bout d'un certain
nombre de générations (les effets commencent à se faire sentir à partir de la 
troisième), la \ofg{sélection naturelle} fait ressortir des jeux de paramètres 
qui peuvent notablement améliorer le score du jeu initial.

\subsection{Sélection initiale des candidats}

Le génome initial des candidat est choisi aléatoirement en prenant une valeur 
entre 0 et 10 pour chacun des 6 paramètres que l'on doit fournir au programme 
principal. On prend tout de même un candidat correspondant au jeu de 
paramètres par défaut pour avoir un élément de comparaison et pouvoir décider 
si le jeu de paramètres trouvés par l'algorithme est meilleur ou non que le 
jeu initial.

\begin{code}
\input{creation.py}
\end{code}

\subsection{Organisation du tournoi}

Le tournoi en lui-même consiste simplement à appeler l'exécutable Caml sur les 
problèmes voulus avec les paramètres portés par chaque candidat. On récupère 
le score obtenu sur chaque problème de sorte à pouvoir classer les candidats 
en fonction de leur score total sur l'ensemble des problèmes que l'on choisit 
de tester afin d'obtenir un jeu de paramètres qui réussisse au mieux dans la 
plupart des cas qui se présentent. Afin de conserver une trace écrite, on 
rentre les résultats pour chaque problème dans la base de données 
préalablement initialisée.

\subsection{Reproduction des meilleurs}

Après sélection des 4 meilleurs de la génération en cours, on les 
\ofg{reproduit} deux à deux pour essayer de trouver les \ofg{gènes} qui ont 
permis cette réussite. On pondère le mélange de gènes en fonction de la 
réussite au tournoi précédent de sorte à favoriser légèrement le plus fort. 
Néanmoins, on introduit un brin d'aléatoire de deux manières différentes:
\begin{enumerate}
	\item	9 fois sur 10, on fait la moyenne pondérée des gènes des deux 
	reproducteurs avec le poids précédent auquel on rajoute un facteur 
	(positif ou négatif) aléatoire pour s'assurer que tous les gènes ne sont 
	pas mélangés toujours dans les mêmes proportions\footnote{Comme Harry 
	Potter, on peut très bien hériter des yeux de sa mère et pourtant avoir 
	globalement le même visage que son père.}.
	
	\item	1 fois sur 10, une mutation majeure intervient et les gènes 
	parentaux sont tout bonnement ignorés. Le gène de l'enfant est alors tiré 
	de manière aléatoire sur l'ensemble des valeurs initialement prévues.
	
\end{enumerate}

\begin{code}
\input{repro.py}
\end{code}

\subsection{Importance des mutations et du sang neuf}

Tout comme dans la vraie vie, le consanguinisme guette dès que l'on procède à 
la reproduction des candidats. C'est d'autant plus vrai ici que le programme 
Caml impose aux paramètres d'être des entiers. Même avec un soupçon 
d'aléatoire dans le brassage, mélanger deux fois la même valeur pour un 
paramètre donné redonne la même valeur. Si cette valeur fournit 
effectivement un avantage dans le tournoi, les meilleurs places seront brigués 
par les mêmes candidats. Il n'y aura plus d'évolution qui pourrait permettre 
de trouver un jeu de paramètres inédit et qui amènerait pourtant de meilleurs 
résultats. C'est pourquoi les mutations sont particulièrement importantes et 
leur pourcentage d'apparition (ici $10\%$ de chance) est un paramètre sur 
lequel on peut jouer pour optimiser l'algorithme génétique lui-même.

Néanmoins, ces mutations peuvent ne pas être suffisantes pour explorer 
efficacement l'espace des paramètres, c'est pourquoi on a choisi de prendre 
12 candidats pour chaque génération: 
\begin{itemize}
	\item Quatre d'entre eux sont issus de la génération 
précédente et remettent simplement leur titre en jeu\footnotemark{}. 

	\item Les six suivants sont les candidats \ofg{fils} qui
correspondent aux six appariements deux à deux des quatre candidats précédents.

	\item	Enfin, les deux places restantes sont constituées d'individus au 
	génome totalement nouveau et choisi aléatoirement pour permettre 
	d'explorer d'autres possibilités.

\end{itemize}

L'ensemble permet assez rapidement de trouver de nouveaux arrangements qui 
améliorent sensiblement les choix initiaux, les points forts de chaque 
individus étant patiemment sélectionnés pour se développer lors des 
générations ultérieures.

%\subsection{Remarque concernant les calculs à faire}

\footnotetext{Bien entendu, comme il n'y a pas d'aléatoire dans le problème et 
que chaque joueur joue absolument seul, il ne sert à rien de faire tourner à 
nouveau les jeux de paramètres des parents dans le nouveau tournoi vu qu'ils 
donneront exactement le même résultat qu'avant (ce ne serait pas le cas par 
exemple dans un jeu où l'on affronte un autre joueur en combat singulier et 
que notre stratégie peut être dépendante des mouvements de l'adversaire). 
C'est pourquoi les résultats ont été stockés dans une base de données 
\texttt{sqlite3} et seuls les calculs sur les candidats fils ainsi que les 
nouveaux candidats aléatoires sont utilisés.}
